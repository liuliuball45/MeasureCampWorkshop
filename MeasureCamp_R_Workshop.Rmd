---
title: 'MeasureCamp R Workshop'
subtitle: 'The Basics of R'
author: "Longhow Lam"
output:
   prettydoc::html_pretty:
     highlight: github
     theme: cayman
     toc: true
     toc_depth: 2
     number_sections: true
     css: mycayman.min.css
   pdf_document:
     toc: yes
     toc_depth: '2'
   html_notebook:
     theme: sandstone
     toc: true
     toc_depth: 2
     toc_float: true
     number_sections: true
---


![](measurecamp.PNG)

<br>


# The RStudio Environment

---


Start with powerpoint slides over R followed by an intro in RStudio:

* Console,
* Script windows,
* Environment tab (Object browser),
* Packages.

![](RStudio.png)

## De R Console

The R Console is a place where you can quickly run a short piece of code. Type in an R expression and Enter to run. Output of scripts also appears in the R Console.



## Scripts 

R Script files are ordinary text files (*.R) with R code. In RStudio you can open and edit multiple scripts. Scripts that belong together can be put in an R Project. Via the File menu> New File> R Script you can create a new R script file in RStudio. Or use the short cut: Ctrl + Shift + N.

In an R script you type code and if you move the cursor on a line you can run that line of code by pressing `Ctrl + Enter`. You can also select multiple lies and run these lines with `Crtl + Enter`. For more options see the Code menu and 'Run Region'.


## R Notebooks / R Markdown files

R notebooks and R Markdown files contain more than just R code, it is a 'complete' document with R code, output and a descriptive storyline. In an R project you can also manage several of these notebooks (or markdown files) and scripts. Note books are created with Rmarkdown, a sort of light weight markup language in which you can specify headers, figures and bold prints, for example. This R course is written in an R markdown file. A notebook / markdown file contains ** R code chunks ** that you can run.


If you press the 'Preview' button above the R notebook you will see a separate window with the **result of the R notebook**. Therefore, RStudio creates a separate file that has the name `<file_name>.nb.html`. This is a html file that you can share with others.
 
Besides the nb.html, you can also "knit" an R notebook / markdown file into an html, pdf or Word document. The header of the markdown document tells how to knit a few things. See for example this document. Next to the 'Preview' button you will see an arrow from which you can choose.


## R Projecten

Organize your R work in projects. A project can consist of different scripts, notebooks, data and output, which you would like to have in one folder. In RStudio you can work very conveniently with different R projects. Through the RStudio interface you can create and manage projects: File> New Project...


## Git version controle

Git is a version control system. In RStudio you can easily use git. You will have to install it first. On Windows you can install git via [the git site] (https://git-scm.com/download/win). We will not discuss this further in this workshop.


## A few simple R expressions to get started

Hieronder een paar simpele expressies in R om te beginnen

```{r, eval=FALSE}
1 + 1
print("hello world")

## assignment kan je = of <- gebruiken,
## pijltje stamt nog uit een tijd waar het een toets op het toetsenbord was

## Als je onderstaande regel runt wordt het object test gemaakt, je ziet nog verder niks
test = 9

## Om te zien wat er in het object test zit moet je het printen
## Dit doe je door het volgende code te runnen, nu zie je iets verschijnen
print(test)

## Omdat je best vaak snel wilt zien wat er in een object zit volstaat alleen de naam ook
## dus run de volgende regel
test

## als een object al bestaat wordt die zonder waarschuwingen overschreven
test <- 3
test
```


# Data types 

---

Alle data in R is van een bepaalde type, we zullen de verschillende data types hieronder behandelen. met de functie `typeof` kan je het type altijd opvragen van een object in R.

## Numerical data

### double data tupe

De `double` datatype in R wordt vaak gebruikt om numerieke waarden ('alledaagse' getallen te representeren). Denk bijvoorbeeld aan kenmerken van mensen zoals lengte ( 1.85) of gewicht (78.8).  

```{r, eval=FALSE}
x4 = 4
x5 = 5.6 / 8

x6 = pi/2

is.double(x4)

```


### integer data type

Het `integer` data type in R representeren ook numerieke waarden. Alleen in tegenstelling tot doubles representeren ze alleen gehele getallen. Bijvoorbeeld een tel variabelen, aantal kinderen (0, 1, 2,...).

```{r, eval=FALSE}
# let op, onderstaande zijn nog doubles in R.
x = 1
y = 2

is.integer(x)

x = as.integer(1)
z = x + 9.78

is.integer(z)

y = 34L
is.integer(y)

x7 = 4L
is.double(x7)

# in tegenstelling tot sommige andere talen kan je in R double en integers 
# in berekeningen zonder vertalingen gebruiken

x8 = x4 + x7
typeof(x8)
```

## character data type

In R kan je met het `character` data type teksten (of ook soms strings genoemd) opslaan. Bewerkingen en manipulaties van characters in sessie 2.

```{r, eval=FALSE}
x1 = "Longhow Lam"
x2 = "1628 AA Hoorn"

is.character(x1)

nchar(x2)

x3 = paste(x1, x2)
x3 = paste(x1, x2, sep="")
```


## factor data type

In R, `factors` are meant to represent categorical variables. For example, gender, or education. Do not confuse a factor with the character type, you can create factor variables from character variables. In some predictive modeling functions you explicitly need factor variables and not character.

Consumer data sets may include names or surnames of persons of the type character, but for example the gender or education are often of the type of factor.


```{r, eval=FALSE}
x3 = c("M", "F", "M")

is.character(x3)
typeof(x3)

y3 = as.factor(x3)
x3
y3
```


## logical data type

Als je in R een test uitvoert, dan is het resultaat van het type `logical`. We zagen al de functies `is.double` en `is.integer`.

```{r, eval=FALSE}
x7 = TRUE
x8 = FALSE

typeof(x7)

x9 = x6 < 8

is.logical(x9)

x1 = as.integer(1)
x2 = 1

x1
x2
```

Merk op dat in R, een double gelijk kan zijn aan een integer, in andere talen kan dit anders zijn.

```{r, eval = FALSE}
is.integer(x2)
is.integer(x1)

x1 == x2
```

Het volgende blokje code laat logische operatoren zien.

```{r, eval=FALSE}
# ampersand is testen op "DIT"" EN "DAT""
TRUE & FALSE    # AND

x = 9
x < 10 & x > 5

# negatie, tegenovergestelde
!TRUE           # NOT
!FALSE

# vertical pipe is testen op "dit"" OF "dat""
TRUE | FALSE    # OR
x < 7 | x > 8
```

Je kan rekenen met logicals

```{r, eval = FALSE}
TRUE + TRUE
FALSE + FALSE + TRUE

### What the F...

0.1 + 0.2 == 0.3

1 + 2 == 3
x = 0.3

sprintf("%.16f", x)
sprintf("%.24f", x)
```


## missing values

Missing values can be represented in R with `NA`. You can have missing doubles, integers, etc.

```{r, eval=FALSE}
x3 = NA

# gebruik is.na om te checken of iets NA is
is.na(x3)

# een rijtje getallen waarbij eentje missend is
x4 = c(1, 2, 3, 4, NA, 5, 7)

# hoeveel elementen zijn NA en niet NA
sum(is.na(x4))
sum(!is.na(x4))

x4 < 4

is.na(x4)
```



# Data structures

---


Data in R kan in verschillende vormen verschijnen, de zogenaamde data structuren. We zullen hieronder een aantal basis structuren behandelen.

## vectors

Vectoren worden gebruikt om een 'rijtje' elementen op te slaan. Je kan een vector van doubles hebben, characters etc... Alle elementen kunnen alleen van hetzelfde type zijn!

```{r, eval=FALSE}
## een getal is ook al een vectpr, van lengte 1
x0 = 1

x1 = c( 1, 2, 3, 4, 5)
length(x1)
class(x1)

x2 = c(2L, 3)
typeof(x2)

x3 = c("p", 2)
```

Er zijn diverse functies in R die je kan gebruiken om vectoren te genereren zonder alle elementen een voor een in te typen :-)

```{r, eval = FALSE}
x1 = 1:1000
x1 = 187:278

x2 = seq(1, 50, length=100)
x2a = seq(1,500, by = 20)

## samenvoegen van twee of meer vectoren
x3 = c( x0, rnorm(100))

class(x4)
```


Het genreren van wat random getallen is handig om snel wat data te hebben om te testen, in R zijn er diverse functies.

```{r, eval=FALSE}
# normaal verdeelde getallen
rnorm(100)
rnorm(100, 9, 2)

#uniform verdeelde getallen
runif(100)
runif(100,8,10)

# trekken uit een vector
x4 = sample( letters, rep = TRUE, size = 100)
```


Berekeningen op vectoren gebeuren elements-gewijs

```{r, eval=FALSE}
y = 3 * x3 + 8

## en wat is dit???
y = x4 + 8

x4 = rep(1:6, 7)
x4 = rep(x4,8)

x5 = rep(1:10, each = 3)
```

De functie `cut` om factor vectoren te maken uit double vectoren

```{r}
x <- rnorm(100)
y <- cut(x, 4)
```



### subscripting of vectors

Hoe benader je elementen in een vector? Dat kan met subscripts

```{r, eval=FALSE}
## R begint te tellen bij 1
x3 = 100:200

## subscripts zijn : 1 getal, een vector van getallen, negatieve getallen
x3[1]
x3[  4:10  ]
x3[  -(1:10)]

## gebroken kan ook...
x3[8.9]

## je kan met subscripts ook elementen veranderen
x3[  8:17  ] = 0
```

Je kan ook een vector van TRUE/FALSE opgeven als subscript.

```{r, eval=FALSE}
x = rnorm(100)
x[x > 2]

```

Een paar simpele functies die je op vectoren kan toepassen

```{r, eval=FALSE}
y = rnorm(1000)

mean(y)
var(y ) 
min(y)
sd(y)
max(y)
summary(y)

sum(y < 0)
```


##  Matrices

Een matrix is een verzameling van vectoren die even lang zijn. Je kan rechthoekige (aantal rijen anders dan aantal kolommen) of vierkande matrices (aantal rijen = aantal kolommen) hebben.

```{r, eval=FALSE}
## maak een matrix van een vector
m1 = rnorm(100)
m2 = matrix(m1, byrow = FALSE, ncol=10)
m2
dim(m2)
class(m2)

## maak een matrix van een aantal vectoren
x = 1:10
y = 10:1
z = 11:20

m3 = cbind(x,y,z)
m4 = rbind(x,y,z)
```

Net als vectoren kan je elementen in een matrix benaderen met subscripts, hieronder volgen een aantal voorbeelden.

```{r, eval = FALSE} 
m2[1,5]

m2[  4:10,    3:5]

m2[5,]

m2[ ,5]
```

Met matrices kun je rekenen. Een paar typische matrix bewerkingen.

```{r, eval =FALSE}
# determinant van een matrix
det(m2)

# matrix transponeren
t(m2)

# inverse van een matrix
solve(m2)

# er zijn twee soorten vermenigvuldigingen van matrices
m2 %*% solve(m2)
m2 * solve(m2)

round(m2 %*% solve(m2))
```

## data frames

Een data frame kan je zien als een matrix, maar in tegenstelling tot een matrix, kunnen kolommen van een data frame van een andere type zijn. Voor data analyse met 'echte' data zal een data.frame de meest handige structuur zijn. je hebt bijvoorbeeld een factor kolom 'Geslacht', een double kolom met bijvoorbeeld 'geweicht' en je kan een character kolom hebben met 'achternaam'.


```{r, eval=FALSE}
x1 = 1:100
x2 = rnorm(100)
x3 = rnorm(100)
x4 = sample(c("M","F"), size = 100, replace = TRUE)

df1 = data.frame(
  kolomnaampj1 = x1,
  income = x2,
  age = x3,
  type = x4
)

# laat eerste 10 rijen zien
head(df1,10)
```

De volgende functies kan je gebruiken om wat extra info van een data frame te laten zien.

```{r, eval=FALSE}
# laat de namen van de kolommen zien
names(df1)

# names kan je ook gebruiken om bestaande kolomnamen te wijzigen
df2 = df1
names(df2) = c("A", "B", "C", "D")

# dimensie en classe
dim(df1)
class(df1)

# De levels van kolom 'type' uit mydf
levels(mydf$type)

### pas op met characters die worden standaard in data.frame naar factors omgezet
x4
class(x4)
class(df1$type)

mydf = data.frame(kolomnaampj1 = x1, income = x2, age=x3, type = x4, stringsAsFactors = FALSE)
mydf
class(mydf$type)

## Dit is ook in de Environment viewer te zien
```

Je kan net als bij matrices subscripts gebruiken in data frame om bepaalde data uit een data.frame te halen

```{r, eval=FALSE}
df1[1,3]
df1[11:20,]

df1[, 2:3]
df1$income

## kolom toevoegen
df1$NEW = df1$income / 100
df1
```



# Importing data

---

## using the gui

## using functions from `readr`

## data base connection



---

# Data preparation and Manipulation

---

## tidyverse


## dplyr

## strings



# Data visualisation

---

## ggplot

## plotly

## leaflet


## visnetwork



# Machine learning

---

In R you can create different machine learning models, in this script I wlll demo supervised machine learning:

* regression, with lm
* classification, with glm, rpart and h2o

In supervised learning you are predicting an observed 'Target', observed 'behaviour' from data. When this target is binary we have a classifiaction problem. For example we observed whether or not customers responded to a mailing, whether or not a customer had a car accident. When this target is numeric we have a regression problem. 


I'll also show market basket analaysis with the package `arules`. A technique to o analyse transactional data. For example physical purchases in suprmarket or web clicks on a site.


## Lineare regressie 

We beginnen met simpele lineaire regressie, bruikbaar voor voorspel modellen waar de Target variable continu (numeric) is. We nemen als voorbeeld huizen prijs data die ik gescraped heb van jaap.nl. We willen de prijs van een huis voorspellen basis van een aantal input variabelen/kenmerken.

```{r, eval = FALSE}
jaap = readRDS("Jaap.RDs")

modelout  = lm( prijs ~ kamers               , data = jaap)
modelout2 = lm( prijs ~ kamers + Oppervlakte , data = jaap) 

modelout
modelout2
```

Modeling functies in R retourneren objecten met van alles er nog wat in. De functie `lm` levert een object af van de klasse lm.

```{r, eval = FALSE}
class(modelout)
names(modelout)
modelout$coefficients

summary(modelout)
plot(modelout)
```

Je ziet dat er wat outliers in de data zitten, die kunnen we nog eens er uit filteren

```{r, eval=FALSE}
library(dplyr)
jaap = jaap %>% filter( prijs < 2000000 )
modelout  = lm( prijs ~ kamers              , data = jaap)
modelout2 = lm( prijs ~ kamers + Oppervlakte , data = jaap) 
```

Iets mooiere diagnostische plots uit `lm` objecten krijg je met de library `ggfortify` die weet hoe je lm objecten moet interpreteren voor ggplot. Dan kan je met de functie `autoplot` uit ggplot mooiere diagnostische plots maken.

```{r, eval = FALSE}
library(ggfortify)
library(ggplot2)

ggplot2::autoplot(modelout)
```

### formula objects

Modellen in R kan je specificeren met zogenaamde de formula objects. Hieronder zie je een aantal voorbeelden.

```{r, eval = FALSE}
names(jaap)
jaap = jaap %>% mutate(PC1Positie = stringr::str_sub(PC,1,1))

jaap = jaap %>% filter(
  !is.na(Oppervlakte),
  !is.na(kamers),
  !is.na(PC1Positie)
  )

f0 = prijs ~ Oppervlakte + kamers 
m0 = lm(f0, data = jaap)
m0
summary(m0)

f1 = prijs ~ Oppervlakte + kamers + PC1Positie
m1 = lm(f1, data = jaap)
m1
summary(m1)


## interactie termen
f2 = prijs ~ Oppervlakte*kamers*PC1Positie
m2 = lm(f2, data = jaap)
summary(m2)


##  termen weglaten
f3 = prijs ~ Oppervlakte*kamers*PC1Positie - Oppervlakte:kamers:PC1Positie
m3 = lm(f3, data = jaap)
summary(m3)

## een target en de rest van de variabelen als inputs
f4 = prijs ~ . -PC6 -PC
m4 = lm(f4, data = jaap)
summary(m4)
```


Als je verschillende model objecten hebt gemaakt kan je de functie `anova` gebruiken om ze met elkaar te vergelijken. Dit gebeurt met behulp van F statistics. De modellen moeten wel oplopend in complexiteit zijn.


```{r, eval =FALSE}
anova(m0, m1, m3, m2)
```

### Buckets / linear constant  en splines 

Als een input variable niet linear is mbt de target kan je deze niet lineariteit modelleren met buckets (linear constante stukken) of met splines.

```{r, eval = FALSE}
library(ggplot2)
library(dplyr)
library(splines)

jaap %>% filter(prijs < 1000000, Oppervlakte < 1500) %>%ggplot(aes(x=Oppervlakte, y= prijs)) + geom_point()

mybreaks = seq(0,1000, by = 25)
jaap = jaap %>% mutate(OppervlakteBucket = cut(Oppervlakte, breaks = mybreaks))


m1 = lm(prijs ~ Oppervlakte, data = jaap)
m2 = lm(prijs ~ OppervlakteBucket, data = jaap)
m3 = lm(prijs ~ ns(Oppervlakte,6), data = jaap)

summary(m1)
summary(m2)
summary(m3)

```

###  predicties

Met de functie `predict` kunnen we nieuwe huizen scoren, dat wil zeggen de prijs van andere huizen die niet in de training data set zaten voorspellen.


```{r, eval=FALSE}
NieuweHuizen = data.frame(
  Oppervlakte = seq(20, 250, l = 100)
  ) %>%
  mutate(
   OppervlakteBucket = cut(Oppervlakte, breaks = mybreaks)
  )

# Bucket predicties
prijs2 = predict(m2, newdata = NieuweHuizen)
NieuweHuizen$prijs2 = prijs2

ggplot(NieuweHuizen, aes(x=Oppervlakte, y = prijs2)) + geom_line()

# Spline predicties
prijs3 = predict(m3, newdata = NieuweHuizen)
NieuweHuizen$prijs3 = prijs3


ggplot(NieuweHuizen, aes(x=Oppervlakte, y = prijs2)) + geom_point() + geom_point(aes(y=prijs3), col=2)

```


## Classification

We use insurance data from the library `insuranceData` to demonstrate classification models.


descion tree plotten
```{r, eval = FALSE}
library(rpart)
# Complex tree
data("solder")
res <- rpart(Opening~., data = solder, control = rpart.control(cp = 0.00005))
visTree(res, height = "800px", nodesPopSize = TRUE, minNodeSize = 10, maxNodeSize = 30)
```


## market basket

Met market basket analyse (ook wel association rules mining genoemd) kan je uit "transacties van klanten" vaak voorkomende combinaties of juiste hele "sterke combinaties" van producten bepalen. Hieronder volgt een voorbeeldje op een fictief grocery data setje.

Vanuit transactionele data moet je in R de data converteren naar een zogenaamde `transaction object`. Dit kan je doen met het `arules` package.

```{r, eval = FALSE}
library(arules)
## De meest simpele transactionele data set
trxDF = readRDS("boodschappen.RDs")

## Transormeer naar een transaction object
Groceries = as(
  split(
    trxDF$item,
    trxDF$id
    ),
  "transactions"
)
Groceries

## Visuele Item informatie
itemFrequencyPlot(Groceries, topN = 35, cex.names = 0.75)

rules <- apriori(Groceries, parameter = list(supp = 0.001, conf = 0.8))
```


Nu je de regels hebt kan je filteren op regels. Welke regels bevatten bepaalde producten.

```{r, eval = FALSE}
rules.subset2 <- subset(rules, lhs %in% c("cereals", "curd"))
rules.subset2
inspect(head(rules.subset2,n=15))
```

Of als iemand een bepaalde reeks transacties heeft welke regels horen daar bij en welk product kan je dan aanraden.

```{r, eval = FALSE}
PersoonA = data.frame(
  id = rep(1,3),
  item2 = c("butter","curd","domestic eggs")
)

trxs_trans = as(
  split(
    PersoonA$item2,
    PersoonA$id
    ),
  "transactions"
)
inspect(trxs_trans)

rulesMatch <- is.subset(rules@lhs,trxs_trans)

## er zijn meerdere regels, je zou degene met de hoogste lift kunnen kiezen
inspect(rules[rulesMatch[,1]])
inspect(rules[rulesMatch[,1]]@rhs)
```

Een ander manier om regels weer te geven is in een network graph, de verzameling regels vormen in feite een netwerk. A --> B, B --> C, D --> B bijvoorbeeld.

```{r, eval=FALSE}
library(arulesViz)
plot(head(sort(rules, by = "lift"), n=50), method = "graph", control=list(cex=.8))
```

### interactive MBA graphs

You can visualise rules in interactive plotly plots or interactive visNetwork plots. First, an interactive scatter plot of the rules can be made. Each rule is plotted as a point, where the x axis represents the support and the y axis represent the confidence of the rule.

```{r, eval=FALSE}
rules <- apriori(Groceries, parameter = list(supp = 0.001, conf = 0.8) )
rulesDF = rules %>% DATAFRAME()

library(plotly)
plotly_arules(rules, max = 2000)
plotly_arules(rules, method = "two-key plot")
```

Secondly, an interactive visNetwork can be created. We need to extract the nodes and edges from the rules object.

```{r, eval=FALSE}
library(visNetwork)

rules <- apriori(
  Groceries, 
  parameter = list(
    supp = 0.0001, 
    conf = 0.1, 
    minlen = 2,
    maxlen=2
    )
  )

rulesDF = head(
  sort(rules, by = "lift"),
  n=250
  ) %>% 
  DATAFRAME() %>%
  mutate(
    from = as.character(LHS),
    to = as.character(RHS),
    value = lift
  )

nodes = data.frame(
  id = base::unique(c(rulesDF$from, rulesDF$to)),
  stringsAsFactors = FALSE
) %>% mutate(
  title = id
)

visNetwork(nodes, rulesDF) %>%
   visOptions(highlightNearest = TRUE,  nodesIdSelection = TRUE) %>%
   visEdges(smooth = TRUE) 
```

